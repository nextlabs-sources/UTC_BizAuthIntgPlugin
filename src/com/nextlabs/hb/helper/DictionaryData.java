package com.nextlabs.hb.helper;import java.sql.Timestamp;import java.util.ArrayList;import java.util.Collection;import java.util.Date;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.StringTokenizer;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import com.bluejungle.dictionary.Dictionary;import com.bluejungle.dictionary.DictionaryException;import com.bluejungle.dictionary.ElementFieldData;import com.bluejungle.dictionary.IDictionaryIterator;import com.bluejungle.dictionary.IElementField;import com.bluejungle.dictionary.IElementType;import com.bluejungle.dictionary.IEnrollment;import com.bluejungle.framework.comp.ComponentManagerFactory;import com.bluejungle.framework.expressions.IPredicate;public class DictionaryData extends DataRetrival {	// getUsers and their all attributes	private static final Log log = LogFactory.getLog(DictionaryData.class);	private HashMap<String, ArrayList<Integer>> ilnoAuthoritiyIDMapping = null;	public DictionaryData(			HashMap<String, ArrayList<Integer>> ilnoAuthoritiyIDMapping) {		filePath = PluginConstants.INSTALL_LOC + PluginConstants.CC_ROOT				+ PluginConstants.JAR_FOLDER + PluginConstants.APP_FOLDER				+ PluginConstants.DATA_FOLDER				+ PluginConstants.USERDATAFILENAME;		this.ilnoAuthoritiyIDMapping = ilnoAuthoritiyIDMapping;	}	@Override	public void prepareData() {		HashMap<String, HashMap<String, String>> userTableDataMap = new HashMap<String, HashMap<String, String>>();		HashMap<String, ArrayList<HashMap<String, String>>> userCountryMappingMap = new HashMap<String, ArrayList<HashMap<String, String>>>();		HashMap<String, ArrayList<HashMap<String, String>>> userLicensesMap = new HashMap<String, ArrayList<HashMap<String, String>>>();		List<HashMap<String, String>> usertable = getUserData();		if (usertable != null) {			log.debug("Inside Get prepareData usertable length"					+ usertable.size());			for (HashMap<String, String> record : usertable) {				HashMap<String, String> common = new HashMap<String, String>();				String clockId = record.get("clockid");				String windowssid = record.get(PluginConstants.COMMON_PROPS						.getProperty("windowssid"));				String userId = record.get(PluginConstants.COMMON_PROPS						.getProperty("userid"));				/* log.debug("record:" + record); log.debug("windows sid:" +				 * windowssid); log.debug("userid: " + userId);				 * log.debug("clockid:" + clockId); */				try {					if (clockId != null) {						if (windowssid != null && userId == null) {							if (userTableDataMap.get(clockId) == null) {								common.put(PluginConstants.COMMON_PROPS										.getProperty("user_col_WindowsSID"),										windowssid);								common.put(PluginConstants.COMMON_PROPS										.getProperty("user_col_UserID"), "");								prepareAllTableRecord(userCountryMappingMap,										userLicensesMap, userTableDataMap,										common, record, clockId);							} else {								/* log.debug("Merging sid" + windowssid + " uid"								 * + userTableDataMap .get(clockId)								 * .get(PluginConstants.COMMON_PROPS								 * .getProperty("user_col_UserID")) +								 * " old record:" +								 * userTableDataMap.get(clockId) + "new record"								 * + record); */								common.put(PluginConstants.COMMON_PROPS										.getProperty("user_col_WindowsSID"),										windowssid);								common.put(										PluginConstants.COMMON_PROPS												.getProperty("user_col_UserID"),										userTableDataMap												.get(clockId)												.get(PluginConstants.COMMON_PROPS														.getProperty("user_col_UserID")));								userTableDataMap										.get(clockId)										.put(PluginConstants.COMMON_PROPS												.getProperty("user_col_WindowsSID"),												windowssid);								userTableDataMap.put(										clockId,										prepareuserTableRecord(record,												userTableDataMap.get(clockId)));								addtheMissingField(										userCountryMappingMap,										userLicensesMap,										PluginConstants.COMMON_PROPS												.getProperty("user_col_WindowsSID"),										windowssid, clockId, common, record);							}						} else if (userId != null && windowssid == null) {							if (userTableDataMap.get(clockId) == null) {								common.put(PluginConstants.COMMON_PROPS										.getProperty("user_col_WindowsSID"), "");								common.put(PluginConstants.COMMON_PROPS										.getProperty("user_col_UserID"), userId);								prepareAllTableRecord(userCountryMappingMap,										userLicensesMap, userTableDataMap,										common, record, clockId);							} else {								/* log.debug("Merging uid" + userId + " sid" +								 * userTableDataMap .get(clockId)								 * .get(PluginConstants.COMMON_PROPS								 * .getProperty("user_col_WindowsSID")) +								 * " old record:" +								 * userTableDataMap.get(clockId) + "new record"								 * + record); */								userTableDataMap										.get(clockId)										.put(PluginConstants.COMMON_PROPS												.getProperty("user_col_UserID"),												userId);								common.put(PluginConstants.COMMON_PROPS										.getProperty("user_col_UserID"), userId);								common.put(										PluginConstants.COMMON_PROPS												.getProperty("user_col_WindowsSID"),										userTableDataMap												.get(clockId)												.get(PluginConstants.COMMON_PROPS														.getProperty("user_col_WindowsSID")));								userTableDataMap.put(										clockId,										prepareuserTableRecord(record,												userTableDataMap.get(clockId)));								addtheMissingField(										userCountryMappingMap,										userLicensesMap,										PluginConstants.COMMON_PROPS												.getProperty("user_col_UserID"),										userId, clockId, common, record);							}						} else if (userId != null && windowssid != null) {							common.put(PluginConstants.COMMON_PROPS									.getProperty("user_col_WindowsSID"),									windowssid);							common.put(PluginConstants.COMMON_PROPS									.getProperty("user_col_UserID"), userId);							prepareAllTableRecord(userCountryMappingMap,									userLicensesMap, userTableDataMap, common,									record, clockId);						}					}				} catch (Exception e) {					log.error(							"Error in preparation of user Data:"									+ e.getMessage(), e);					log.debug("clockId" + clockId);					log.debug("userId" + userId);					log.debug("windowssid" + windowssid);				}			}			responseData.put(					PluginConstants.COMMON_PROPS.getProperty("table_user"),					new ArrayList<HashMap<String, String>>(userTableDataMap							.values()));			responseData.put(					PluginConstants.COMMON_PROPS.getProperty("table_ucm"),					prepareResult(userCountryMappingMap));			responseData.put(					PluginConstants.COMMON_PROPS.getProperty("table_uam"),					prepareResult(userLicensesMap));			log.info("user"					+ responseData.get(							PluginConstants.COMMON_PROPS									.getProperty("table_user")).size());			log.info("usercountyr"					+ responseData.get(							PluginConstants.COMMON_PROPS									.getProperty("table_ucm")).size());			log.info("userauthority"					+ responseData.get(							PluginConstants.COMMON_PROPS									.getProperty("table_uam")).size());		}	}	private synchronized ArrayList<HashMap<String, String>> prepareResult(			HashMap<String, ArrayList<HashMap<String, String>>> tablemap) {		ArrayList<HashMap<String, String>> result = new ArrayList<HashMap<String, String>>();		ArrayList<ArrayList<HashMap<String, String>>> resultList = new ArrayList<ArrayList<HashMap<String, String>>>(				tablemap.values());		for (ArrayList<HashMap<String, String>> temp : resultList) {			result.addAll(temp);		}		resultList = null;		return result;	}	private void addtheMissingField(			HashMap<String, ArrayList<HashMap<String, String>>> userCountryMappingMap,			HashMap<String, ArrayList<HashMap<String, String>>> userLicensesMap,			String key, String value, String clockId,			HashMap<String, String> common, HashMap<String, String> record2) {		ArrayList<HashMap<String, String>> changeRecordList = userCountryMappingMap				.get(clockId);		ArrayList<String> removeList = new ArrayList<String>();		for (HashMap<String, String> record : changeRecordList) {			// log.info("Merge fix add missing field:" + record);			record.put(key, value);			removeList.add(record.get("Type"));		}		ArrayList<HashMap<String, String>> newlist = prepareuserCountryMappingMapList(				record2, common);		// log.info("Mergefix removelist:" + removeList);		for (HashMap<String, String> record : newlist) {			// log.info("Mergefix new list record:" + record);			if (!removeList.contains(record.get("Type"))) {				changeRecordList.add(record);			}		}		userCountryMappingMap.put(clockId, changeRecordList);		ArrayList<HashMap<String, String>> changeLicenseList = userLicensesMap				.get(clockId);		if (changeLicenseList.size() > 0) {			for (HashMap<String, String> record : changeLicenseList) {				record.put(key, value);			}		} else {			userLicensesMap.put(clockId,					prepareuserlicensesListtable(common, record2));		}	}	private void prepareAllTableRecord(			HashMap<String, ArrayList<HashMap<String, String>>> userCountryMappingMap,			HashMap<String, ArrayList<HashMap<String, String>>> userLicensesMap,			HashMap<String, HashMap<String, String>> userTableDataMap,			HashMap<String, String> common, HashMap<String, String> record,			String clockId) {		userTableDataMap.put(clockId, prepareuserTableRecord(record, common));		// building user country records		userCountryMappingMap.put(clockId,				prepareuserCountryMappingMapList(record, common));		HashMap<String, String> userLicenseRecord;		// building user licenses		ArrayList<HashMap<String, String>> userlicensesList = new ArrayList<HashMap<String, String>>();		String license = PluginConstants.COMMON_PROPS.getProperty("licenses");		String separator = PluginConstants.COMMON_PROPS.getProperty(license				+ "_separator");		if (record.get(license) != null) {			StringTokenizer tokens;			// log.info("record.get(license):" + record.get(license));			// log.info("separator:" + separator);			// log.info("ilnoAuthoritiyIDMapping:" + ilnoAuthoritiyIDMapping);			if (separator != null)				tokens = new StringTokenizer(record.get(license), separator);			else				tokens = new StringTokenizer(record.get(license), "|");			if (tokens != null) {				while (tokens.hasMoreTokens()) {					String ilno = tokens.nextToken();					// log.info("ilno:" + ilno);					ArrayList<Integer> authIdList = ilnoAuthoritiyIDMapping							.get(ilno);					// log.info("authIdList:" + authIdList);					if (authIdList != null) {						HashMap<String, String> newcommon = new HashMap<String, String>();						Iterator<String> comiterator = common.keySet()								.iterator();						while (comiterator.hasNext()) {							String key = comiterator.next();							String value = common.get(key);							if (value != null)								newcommon.put(key, value.toLowerCase());						}						for (int authid : authIdList) {							userLicenseRecord = new HashMap<String, String>(									newcommon);							userLicenseRecord.put(PluginConstants.COMMON_PROPS									.getProperty("uam_col_AuthorityId"),									Integer.toString(authid));							userlicensesList.add(userLicenseRecord);						}					}				}			}		}		userLicensesMap.put(clockId, userlicensesList);	}	private ArrayList<HashMap<String, String>> prepareuserCountryMappingMapList(			HashMap<String, String> record, HashMap<String, String> common) {		ArrayList<HashMap<String, String>> userCountryMappingMapList = new ArrayList<HashMap<String, String>>();		HashMap<String, String> userCountryRecord = new HashMap<String, String>(				common);		if (null != record.get(PluginConstants.COMMON_PROPS				.getProperty("countryofbirth"))) {			userCountryRecord.put(					PluginConstants.COMMON_PROPS							.getProperty("ucm_col_countrycode"),					record.get(							PluginConstants.COMMON_PROPS									.getProperty("countryofbirth"))							.toUpperCase());			userCountryRecord.put(PluginConstants.COMMON_PROPS					.getProperty("ucm_col_type"), PluginConstants.COMMON_PROPS					.getProperty("type_countryofbirth"));			userCountryMappingMapList.add(userCountryRecord);		}		if (null != record.get(PluginConstants.COMMON_PROPS				.getProperty("countryofcompany"))) {			userCountryRecord = new HashMap<String, String>(common);			userCountryRecord.put(					PluginConstants.COMMON_PROPS							.getProperty("ucm_col_countrycode"),					record.get(							PluginConstants.COMMON_PROPS									.getProperty("countryofcompany"))							.toUpperCase());			userCountryRecord.put(PluginConstants.COMMON_PROPS					.getProperty("ucm_col_type"), PluginConstants.COMMON_PROPS					.getProperty("type_countryofcompany"));			userCountryMappingMapList.add(userCountryRecord);		}		if (null != record.get(PluginConstants.COMMON_PROPS				.getProperty("countryofcitizenship"))) {			userCountryRecord = new HashMap<String, String>(common);			userCountryRecord.put(					PluginConstants.COMMON_PROPS							.getProperty("ucm_col_countrycode"),					record.get(							PluginConstants.COMMON_PROPS									.getProperty("countryofcitizenship"))							.toUpperCase());			userCountryRecord.put(PluginConstants.COMMON_PROPS					.getProperty("ucm_col_type"), PluginConstants.COMMON_PROPS					.getProperty("type_countryofcitizenship"));			userCountryMappingMapList.add(userCountryRecord);		}		if (null != record.get(PluginConstants.COMMON_PROPS				.getProperty("countryofsecondarycitizenship"))) {			userCountryRecord = new HashMap<String, String>(common);			userCountryRecord					.put(PluginConstants.COMMON_PROPS							.getProperty("ucm_col_countrycode"),							record.get(									PluginConstants.COMMON_PROPS											.getProperty("countryofsecondarycitizenship"))									.toUpperCase());			userCountryRecord.put(PluginConstants.COMMON_PROPS					.getProperty("ucm_col_type"), PluginConstants.COMMON_PROPS					.getProperty("type_countryofseccitizenship"));			userCountryMappingMapList.add(userCountryRecord);		}		return userCountryMappingMapList;	}	private HashMap<String, String> prepareuserTableRecord(			HashMap<String, String> record, HashMap<String, String> common) {		// log.debug("Merge Fix common value: " + common);		HashMap<String, String> userTableRecord = new HashMap<String, String>(				common);		if (record.get(PluginConstants.COMMON_PROPS.getProperty("cgdess")) != null) {			userTableRecord					.put(PluginConstants.COMMON_PROPS							.getProperty("user_col_CGDESS"), record							.get(PluginConstants.COMMON_PROPS									.getProperty("cgdess")));		}		if (record				.get(PluginConstants.COMMON_PROPS.getProperty("cgdessexpiry")) != null) {			userTableRecord.put(PluginConstants.COMMON_PROPS					.getProperty("user_col_CGDEExpiration"), record					.get(PluginConstants.COMMON_PROPS							.getProperty("cgdessexpiry")));		}		if (record.get(PluginConstants.COMMON_PROPS.getProperty("company")) != null) {			userTableRecord.put(PluginConstants.COMMON_PROPS					.getProperty("user_col_CompanyId"), record					.get(PluginConstants.COMMON_PROPS.getProperty("company")));		}		if (record.get(PluginConstants.COMMON_PROPS.getProperty("usperson")) != null) {			userTableRecord.put(PluginConstants.COMMON_PROPS					.getProperty("user_col_USPerson"), record					.get(PluginConstants.COMMON_PROPS.getProperty("usperson")));		}		if (record.get(PluginConstants.COMMON_PROPS.getProperty("lastname")) != null) {			userTableRecord.put(PluginConstants.COMMON_PROPS					.getProperty("user_col_LastName"), record					.get(PluginConstants.COMMON_PROPS.getProperty("lastname")));		}		if (record.get(PluginConstants.COMMON_PROPS.getProperty("firstname")) != null) {			userTableRecord					.put(PluginConstants.COMMON_PROPS							.getProperty("user_col_FirstName"), record							.get(PluginConstants.COMMON_PROPS									.getProperty("firstname")));		}		if (record.get(PluginConstants.COMMON_PROPS.getProperty("usertype")) != null) {			userTableRecord.put(PluginConstants.COMMON_PROPS					.getProperty("user_col_usertype"), record					.get(PluginConstants.COMMON_PROPS.getProperty("usertype")));		}		// log.debug("Merged userTableRecord: " + userTableRecord);		return userTableRecord;	}	private ArrayList<HashMap<String, String>> prepareuserlicensesListtable(			HashMap<String, String> common, HashMap<String, String> record) {		HashMap<String, String> userLicenseRecord;		// building user licenses		ArrayList<HashMap<String, String>> userlicensesList = new ArrayList<HashMap<String, String>>();		String license = PluginConstants.COMMON_PROPS.getProperty("licenses");		String separator = PluginConstants.COMMON_PROPS.getProperty(license				+ "_separator");		if (record.get(license) != null) {			StringTokenizer tokens;			// log.info("record.get(license):" + record.get(license));			// log.info("separator:" + separator);			// log.info("ilnoAuthoritiyIDMapping:" + ilnoAuthoritiyIDMapping);			if (separator != null)				tokens = new StringTokenizer(record.get(license), separator);			else				tokens = new StringTokenizer(record.get(license), "|");			if (tokens != null) {				while (tokens.hasMoreTokens()) {					String ilno = tokens.nextToken();					// log.info("ilno:" + ilno);					ArrayList<Integer> authIdList = ilnoAuthoritiyIDMapping							.get(ilno);					// log.info("authIdList:" + authIdList);					if (authIdList != null) {						for (int authid : authIdList) {							userLicenseRecord = new HashMap<String, String>(									common);							userLicenseRecord.put(PluginConstants.COMMON_PROPS									.getProperty("uam_col_AuthorityId"),									Integer.toString(authid));							userlicensesList.add(userLicenseRecord);						}					}				}			}		}		return userlicensesList;	}	private List<HashMap<String, String>> getUserData() {		long lCurrentTime = System.nanoTime();		List<HashMap<String, String>> userData = null;		HashMap<String, String> enrollmentClockidMapping = new HashMap<String, String>();		String enrollment_Clockid = PluginConstants.COMMON_PROPS				.getProperty("user_data_synchronizer");		log.info("MERGEFIX Enrollment_clockid : " + enrollment_Clockid);		StringTokenizer enrollment_clockid_tokens = new StringTokenizer(				enrollment_Clockid, ";");		while (enrollment_clockid_tokens.hasMoreTokens()) {			String token = enrollment_clockid_tokens.nextToken();			log.info("MERGEFIX Enrollment_clockid token: " + token);			if (token.contains(":")					&& token.indexOf(":") < (token.length() - 1)) {				String[] enrollment_clockid_arr = token.split(":");				enrollmentClockidMapping.put(enrollment_clockid_arr[0],						enrollment_clockid_arr[1]);			}		}		log.info("MERGEFIX enrollmentClockidMapping: "				+ enrollmentClockidMapping);		try {			log.info("Start Dictionary");			Dictionary dict = ComponentManagerFactory.getComponentManager()					.getComponent(Dictionary.COMP_INFO);			// Getting all the enrollments			Collection<IEnrollment> enrollments = dict.getEnrollments();			userData = new ArrayList<HashMap<String, String>>();			// int enrollCount = 1;			// Loop through the user enrollment data			for (IEnrollment enroll : enrollments) {				// Only getting Active enrollment				if (enroll.getIsActive()) {					Date ct = dict.getLatestConsistentTime();					log.info("Latest consistent time -->"							+ dict.getLatestConsistentTime().getTime());					log.info("MERGEFIX enrollment name: "							+ enroll.getDomainName());					String clockid = enrollmentClockidMapping.get(enroll							.getDomainName());					log.info("MERGEFIX clockid: " + clockid);					// Set Element type to USER					IElementType eType = dict.getType("USER");					IPredicate ipred = dict.condition(eType);					/* IDictionaryIterator<IMGroup> group = dict					 * 					 * .getEnumeratedGroups(ipred, eType, ct, null); IMGroup gr					 * 					 * = group.next(); gr.getU IDictionaryIterator<IMElement>					 * 					 * ie= gr.getAllChildElements(); ie.next().get */					String[] sProperties = enroll.getExternalNames(eType);					// Set ipredicate query only current enrollment					int spropertylength = sProperties.length;					ipred = dict.condition(enroll);					// Query the enrollment					log.info("started the dict query enroll");					IElementField[] iefArray = new IElementField[spropertylength];					for (int i = 0; i < spropertylength; i++) {						log.info("sProperties:"+sProperties[i]);						iefArray[i] = enroll.lookupField(eType, sProperties[i])[0];						log.info("iefArray:"+iefArray[i]);					}					long fieldtime = System.nanoTime();					IDictionaryIterator<ElementFieldData> efdList = dict							.queryFields(iefArray, ipred, ct, null, null);					log.info("efdList:"+efdList);					if (efdList != null) {						try {							while (efdList.hasNext()) {								ElementFieldData efd = efdList.next();								HashMap<String, String> record = new HashMap<String, String>();								// IElementField[] iefield = efd.getFields();								Object[] data = efd.getData();								for (int i = 0; i < spropertylength; i++) {									if (data[i] != null) {										if (!(data[i].getClass().isArray())) {											if (sProperties[i]													.equalsIgnoreCase(clockid)) {												record.put("clockid", data[i]														.toString()														.toLowerCase());											}											record.put(sProperties[i], data[i]													.toString().toLowerCase());											// log.debug("Single Value not a array"+sProperties[i]+":"+data[i].toString());										} else {											String separator = PluginConstants.COMMON_PROPS													.getProperty(sProperties[i]															+ "_separator");											if (separator != null) {												StringBuffer value = new StringBuffer();												Object[] datas = (Object[]) data[i];												for (Object st : datas) {													/* log.info("st val:"													 * 													 * + st.toString()); */													value.append(st.toString());													value.append(separator);												}												record.put(sProperties[i],														value.toString()																.toLowerCase());												/* log.info(sProperties[i] + ":"												 * 												 * + value.toString()); */											} else {												Object[] datas = (Object[]) data[i];												if (datas[0] != null)													record.put(															sProperties[i],															datas[0].toString()																	.toLowerCase());												/* log.info(sProperties[i] + ":"												 * 												 * + datas[0].toString()); */											}										}									}								}								userData.add(record);								// log.info("Record:" + record);							}						} catch (Exception e) {							setErrorMessage(PluginConstants.DATARETRIVALFAILURE);							log.error(e.toString(), e);						} finally {							if (efdList != null)								efdList.close();						}						log.debug("dictionary  fieldtime"								+ ((System.nanoTime() - fieldtime) / 1000000.00)								+ "ms");					} else {						log.info("Userlist is null.");						setErrorMessage(PluginConstants.DATARETRIVALFAILURE);					}				}			}		} catch (Exception ex) {			setErrorMessage(PluginConstants.DATARETRIVALFAILURE);			log.error(ex.toString(), ex);		}		log.debug("dictionary data retrieval() completed. Time spent: "				+ ((System.nanoTime() - lCurrentTime) / 1000000.00) + "ms");		return userData;	}	@Override	public Timestamp getLastModifiedDate() {		Timestamp ct = null;		try {			Dictionary dict = ComponentManagerFactory.getComponentManager()					.getComponent(Dictionary.COMP_INFO);			// Getting all the enrollments			Collection<IEnrollment> enrollments = dict.getEnrollments();			// Loop through the user enrollment data			for (IEnrollment enroll : enrollments) {				// Only getting Active enrollment				log.info("Dictionalry latest time:" + ct);				ct = new Timestamp(dict.getLatestConsistentTime().getTime());				if (enroll.getIsActive()) {					ct = new Timestamp(dict.getLatestConsistentTime().getTime());				}			}		} catch (DictionaryException e) {			log.error("Dictionary Data getLastModifiedDate()" + e.toString(), e);		}		log.info("Dictionalry latest time:" + ct);		return ct;	}}